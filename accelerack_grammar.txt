
Accelerack language grammar(s)
================================================================================

This specification documents the Accelerack language.  The "input
language" should correspond to what is allowed inside (define-acc ...)
and (acc ...) forms.

As of now [2015.12.08], this full grammar is not completely implemented.

Input language:
------------------------------------------------------------

;; Integration with the meta-language:
meta
  = (acc e)
  | (run-acc e)
  | <definitions>

definitions d
  = (define-acc (f x ...) e)
  | (define-acc x e)

scalar-type st
  = Int
  | Bool
  | Double
  | #(st ...)   ; Tuple of Scalars

type t
  = st                ; Scalar Type
  | #(t ...)          ; Tuple Type
  | (Array n t)       ; Array Type
  | (-> t t)          ; Function Type
  | SExp              ; A value in the meta-language
  | a                 ; Type variable
  | (Num a)           ; Numeric type variable

n = non-negative integer

expression e
  = (acc-array a)           ; Literal arrays
  | (map e e)               ; Map is *not* first class
  | (zipwith e e e)
  | (fold e e e)
  | (generate e e ....)     ; N-dimensional generate
  | (stencil3x3 e b e)      ; Take a function, (lambda (x1 .. x9) e)
  | (let (lb ...) e)        ; Let binding
  | x                       ; Variable
  | p                       ; Primitive function
  | (lambda (lp ...) e)     ; Lambda abs
  | (e e ...)               ; Application
  | (if e e e)              ; scalar or array conditionals
  | (vector e ...)          ; Tuple expression
  | (vector-ref e e)        ; Tuple dereference
  | (acc-array-ref e e ...) ; N-dimensional array dereference.
  | (: e t)                 : Type ascription
  | (use x)                 ; (unquote) Import a normal Racket variable

let binding, lb
  = [x e] | [x : t e]

lambda param, lp
  = x | [x : t]

;; Extra sugar to add later: or/and, let*, ...

primops p
  = add1 sub1 + * - /
    sqrt ...

TODO: finish this list.


value v
  = <boolean>
  | <integer>
  | <double>

;; These are of type SExp:
boundary conditions b
  = 'Clamp | 'Mirror | 'Wrap | '(Constant v)

array-data a
  = v                                ; zero-dimensional scalar
  | (a ...), all a have same length  ; (S n)-dimensional data

shape sh = (n ...)


Language verify-acc
------------------------------------------------------------

Verify-acc returns a type-stripped version of the AST meant to be
treated as regular Racket code, not passed on to the rest of the
compiler.


Language post-typecheck
------------------------------------------------------------

Typecheck takes the starting input language above.
In its output language, all binders have explicit types:

  | (let ((x : t e) ...) e)     ; Let binding
  | (lambda ((x : t) ...) e)    ; Lambda abs

Ascription is removed, becaause it becomes redundant.

Language post-normalization
------------------------------------------------------------

All array operators are directly followed by lambdda:

  | (map        (lambda (x  ) e) e)
  | (zipwith    (lambda (x y) e) e e)
  | (fold       (lambda (x y) e) e e)
  | (stencil3x3 (lambda (x1 .. x9) e) b e)

Application and lambda are removed.
