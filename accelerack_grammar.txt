
Accelerack language grammar(s)
================================================================================

This specification documents the Accelerack language.  The "input
language" should correspond to what is allowed inside (define-acc ...)
and (acc ...) forms.

As of now [2015.12.08], this full grammar is not completely implemented.

Input language:
------------------------------------------------------------

;; Integration with the meta-language:
meta
  = (acc e)
  | (run-acc e)
  | <definitions>

definitions d
  = (define-acc (f x ...) e)
  | (define-acc x e)

scalar-type st
  = Int
  | Bool
  | Double
  | #(st ...)   ; Tuple of Scalars

type t
  = st                ; Scalar Type
  | #(t ...)          ; Tuple Type
  | (Array n t)       ; Array Type
  | (-> t t)          ; Function Type
  | SExp              ; A value in the meta-language

n = non-negative integer

expression e
  = (acc-array a)
  | add1
  | sub1
  | (map e e)
  | (zipwith e e e)
  | (fold e e e)
  | (stencil3x3 e b e)    ; Take a function, (lambda (x1 .. x9) e)
  | (let ((x e) ...) e)   ; Let binding
  | x                     ; Variable
  | (lambda (x ...) e)    ; Lambda abs
  | (e e ...)             ; Application
  | #(e ...)              ; Tuple expression
  | (if e e e)            ; scalar or array conditionals
  | (array-ref e e ...)   ; N-dimensional dereference.

;; Extra sugar to add later: or/and, let*, ...

value v
  = <boolean>
  | <integer>
  | <double>

;; These are of type SExp:
boundary conditions b
  = 'Clamp | 'Mirror | 'Wrap | '(Constant v)

array-data a
  = v                                ; zero-dimensional scalar
  | (a ...), all a have same length  ; (S n)-dimensional data

shape sh = (n ...)


Language post-typecheck
------------------------------------------------------------



Language post-normalization
------------------------------------------------------------

TBD.  Basic idea is to remove lambda as a standalone form.
